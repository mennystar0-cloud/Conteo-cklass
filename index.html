function parseExistenciaCSV(text){
  const raw = text.replace(/\r/g,'').replace(/;/g,','); // ; → , por si Excel
  const lines = raw.split('\n').filter(l => l.trim());
  if (!lines.length) { alert('Archivo de existencia vacío.'); return; }

  // ¿tiene encabezado?
  const firstDelim = detectDelimiter(lines[0]);
  const firstCols  = splitCSVLineFlexible(lines[0], firstDelim).map(x => norm(x).toUpperCase());
  const hasHeader =
    ['MOD','MODELO','SKU','CODIGO-COLOR-TALLA','CLAVE','KEY','COLOR','TALLA','SIZE','CANTIDAD','QTY','STOCK','EXISTENCIA','CANT']
      .some(h => firstCols.includes(h));

  let header = [];
  let delim  = ',';
  let startIndex = 0;

  if (hasHeader) {
    header = firstCols;
    delim  = firstDelim;
    startIndex = 1;
  } else {
    // no hay header: intentamos adivinar delimitador por la segunda línea
    const sample = lines[1] || lines[0];
    delim = detectDelimiter(sample);
    header = []; // sin header, usaremos patrones por línea
    startIndex = 0;
  }

  const idxMap = hasHeader ? findColIdxMap(header, {
    KEY: ['CODIGO-COLOR-TALLA','CLAVE','KEY'],
    MOD: ['MOD','MODELO','SKU'],
    COLOR: ['COLOR','COL'],
    TALLA: ['TALLA','SIZE','NUMERO'],
    CANT: ['CANTIDAD','QTY','STOCK','EXISTENCIA','CANT']
  }) : null;

  const acc = new Map();
  let ok=0, skip=0; const samples=[];

  for (let i=startIndex;i<lines.length;i++){
    const line = lines[i];
    let key = '';
    let qty = 1;

    if (hasHeader) {
      const p = splitCSVLineFlexible(line, delim).map(x => norm(x));

      if (idxMap.MOD>=0 && idxMap.COLOR>=0 && idxMap.TALLA>=0) {
        key = toKey(p[idxMap.MOD], p[idxMap.COLOR], p[idxMap.TALLA]);
      } else if (idxMap.KEY>=0 && p[idxMap.KEY]) {
        const rawKey = p[idxMap.KEY];
        if (rawKey.includes('|')) {
          const [m,c,t] = rawKey.split('|').map(norm);
          key = toKey(m,c,t);
        } else if (rawKey.includes(',')) {
          const [m, tail] = rawKey.split(',');
          const [c, t] = (tail||'').split('-');
          key = toKey(m,c,t);
        } else if (rawKey.includes('-')) {
          const [m,c,t] = rawKey.split('-').map(norm);
          key = toKey(m,c,t);
        }
      }

      if (idxMap.CANT>=0) {
        const num = parseInt((p[idxMap.CANT]||'').replace(/\./g,'').replace(',', ''), 10);
        qty = Number.isFinite(num) && num>0 ? num : 1;
      }
    } else {
      // sin encabezado: soportar formatos libres
      let l = line.replace(/\u00A0/g,' ').trim();   // NBSP → espacio
      l = l.replace(/\s{2,}/g,' ');                // compactar espacios
      l = l.replace(/\s*-\s*/g,'-');               // COLOR - TALLA → COLOR-TALLA

      // 1) "000-24,NEGRO    220   4"
      let m = l.match(/^([^,]+),(.+?)\s+(\S+)\s+(\d+)\s*$/);
      if (m) { key = toKey(m[1], m[2], m[3]); qty = parseInt(m[4],10)||1; }

      // 2) "MOD|COLOR|TALLA[,CANT]"
      if (!key) {
        m = l.match(/^([^|]+)\|([^|]+)\|([^|,]+)(?:\s*,\s*(\d+))?$/);
        if (m){ key = toKey(m[1],m[2],m[3]); qty = parseInt(m[4]||'1',10)||1; }
      }

      // 3) "MOD,COLOR-TALLA[,CANT]"
      if (!key) {
        m = l.match(/^([^,]+)\s*,\s*([^\-\s][^\-]*?)\s*-\s*([^\s,]+)(?:\s*,\s*(\d+))?$/);
        if (m){ key = toKey(m[1],m[2],m[3]); qty = parseInt(m[4]||'1',10)||1; }
      }

      // 4) "CÓDIGO_DE_BARRAS" (buscar en catálogo)
      if (!key && /^\d{6,}$/.test(l)) {
        const it = state.catalog.get(l);
        if (it) { key = toKey(it.MOD,it.COLOR,it.TALLA); qty = 1; }
      }
    }

    if (!key) { skip++; if (samples.length<3) samples.push(`L${i+1}: formato no reconocido`); continue; }
    acc.set(key, (acc.get(key)||0) + qty);
    if (!state.keyMeta.has(key)) {
      const [M,C,T] = key.split('|');
      state.keyMeta.set(key, {MOD:M, COLOR:C, TALLA:T, TEMPORADA:''});
    }
    ok++;
  }

  state.existencia = acc;
  document.getElementById('btnProcesarExistencia').addEventListener('click',()=>{
  const raw = (document.getElementById('existenciaInput').value || '')
    .replace(/\uFEFF/g,'')
    .replace(/\t/g, ',')   // tab → coma
    .trim();
  if (!raw) { alert('No hay texto pegado.'); return; }
  parseExistenciaCSV(raw);
});
}
